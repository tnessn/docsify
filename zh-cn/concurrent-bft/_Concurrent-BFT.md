# PlatON CBFT(Concurrent Byzantine Fault Tolerance)

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Contents**

- [共识](#%E5%85%B1%E8%AF%86)
- [CBFT 简介](#cbft-%E7%AE%80%E4%BB%8B)
- [理论假设](#%E7%90%86%E8%AE%BA%E5%81%87%E8%AE%BE)
- [区块产生](#%E5%8C%BA%E5%9D%97%E4%BA%A7%E7%94%9F)
- [区块验证](#%E5%8C%BA%E5%9D%97%E9%AA%8C%E8%AF%81)
- [区块执行](#%E5%8C%BA%E5%9D%97%E6%89%A7%E8%A1%8C)
- [区块写入](#%E5%8C%BA%E5%9D%97%E5%86%99%E5%85%A5)
- [流程图](#%E6%B5%81%E7%A8%8B%E5%9B%BE)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 共识 

### 理解共识算法

共识，简单理解是指若干的参与者达成一致的意思。在日常生活中也有很多类似的场景，比如开会讨论，双方或多方签订签订一份合作协议等。在区块链系统中，每个节点要做的就是保持自己的账本与其它节点的账本保持一致。在传统的系统架构中，由于存在中心化的系统，各从节点可以容易的从主节点同步数据，各从库向主库看齐即可。就这好比企业老板下达通知，企业员工按规定办事。但是，区块链系统是一个分布式的网络，在所有节点中，谁是老大，该听谁的，谁说了算，谁的命令是有效的，所有这一切都得商量着来。

共识算法是为了解决关于如何让每个节点通过一个规则将各自的数据保持一致的核心问题。它是一个规则，每个节点都按照这个规则去确认各自的数据。

共识算法中的筛选规则，如何筛选？其实就是设置一组条件，给出一组指标让各节点来完成，谁能更好的完成指标，谁就有机会被选中。被选中节点具有代表性、主导性和可信任性。

#### CBFT

`Concurrent Byzantine Fault Tolerance`, 并行拜占庭容错系统。在保证活性、安全性和高效性的前提下，提供了 `(n-1)/3` 的容错性。主要特点支持并行出块及共识，大大的提高了出块的速率，可更好的满足超高频交易量的需求。

**优势**

- 更高的共识效率，可满足高频量的交易场景；
- 共识出块时间可动态调整，出块速度更快可达秒级，达到商业化的实时处理要求；

## CBFT 简介

`CBFT`，即 `Concurrent Byzantine Fault Tolerance` 是指并行的拜占庭将军容错共识，当前出块节点出块后立即广播区块给其他共识节点，其他共识节点在收到区块后对区块进行验证，验证通过后对区块`HASH`进行签名，并将签名广播给其他区块，当任意一个节点收到大于或等于15个签名后，该区块即为不可逆区块。

![P1](./concurrent-bft/images/giskard_blockproduct_1.png)

![P1](./concurrent-bft/images/giskard_blockproduct_2.png)

## 理论假设

为了方便研究，使复杂的问题简单化，同时又能把握问题的本质，`CBFT` 在设计上做了若干假设。

* 区块广播延迟时间小于区块产生的时间间隔;

* 区块重放时间小于（区块时间间隔 - 区块广播延迟时间）;


## 区块产生

出块节点产生区块后，将按照一定规则确定提议区块的顺序，每个提议节点将有`O`秒的时间来出块，各个验证人严格按照时间窗口出块并验证其他提议人出的块是否合法。

**假定**：

- `L`：上一轮转周期最后一个区块的产生时间（UTC时间，毫秒）；
- `N`：当前系统时间（UTC时间，毫秒）；
- `I`：当前节点在所有已排序验证人记账节点中的位置；
- `n`：每一轮选取的验证人数；
- `p`：出块间隔（秒）；
- `O`：每个提议人的出块时间窗口(毫秒)/2 - 1000； 
- `D`：当前节点和出块节点的网络延迟平均值（毫秒）；

**即**：

则当前验证节点判断自己是否在出块的窗口期的规则为：

    I * 10 * 1000 < (N - L) % (n * 10 * 1000) < (I + 1) * 10 * 1000

`CBFT` 共识模块在进行判断时，如果符合该公式式，每隔`p`秒会立即基于当前最高合理区块生产下一个区块并广播给其他验证节点。

## 区块验证

当验证节点收到一个由其它节点提议的区块时，首先会确定该区块是否合法，即是否有必要做进一步验证还是丢弃该区块。

### 合法性判断

如果符合以下任一条件，则认为此区块是合法的（需要进一步做验证）：

	I * 10 * 1000 < (N - L - O) % (n * 10 * 1000) < (I + 1) * 10 * 1000
	I * 10 * 1000 < (N - L + O) % (n * 10 * 1000) < (I + 1) * 10 * 1000

如果不符合上述条件，则认为区块是无效块，直接丢弃。

### 合理性判断

区块合法性判断是单纯时间范围的一个粗粒度判定， 在区块合法性判定完成后，需要再做更详细的鉴定， 以确定是否需要对该区块进行签名并广播，区块合理性判定的标准如下：

- 区块是合法的；
- 当前区块的高度符合其作者的时间窗口期；
- 当前区块出块时间和上一个区块时间满足出块时间间隔要求（`p * 90%`）；
- 当前节点最高不可逆区块是该区块的祖先；
- 当前节点没有对其他相同高度区块签名；

符合上述5条件，则认为该区块合理，需要对其进行签名并广播签名。

## 区块执行

当共识节点收到一个新区块后，如果满足：

- 区块是合法区块；
- 当前最高不可逆区块是该区块的祖先；

则需要：

* 执行该区块；
* 如果之前收到过该区块的子孙区块， 则执行其子孙区块；

## 区块写入

当一个区块签名数收集到 `2f + 1` 后，则此块被确认：

* 如果新确认块高**大于**当前不可逆块高，并且当前不可逆块是新确认块祖先，则此新区块成为新的不可逆区块，从此新的不可逆区块开始，查找出子孙中可能的更高不可逆新区块，如果存在更高不可逆区块，则继续切换更高的不可逆区块为当前最高不可逆区块，确定最高不可逆区块后， 需要将新不可逆区块到原来已入链的不可逆区块之间的所有区块入链。
* 如果新确认块高**小于**当前不可逆块，则可能发生分叉。分叉形成的条件是：找到从新确认区块连接到已入链块，并且此新确认块高是离此已入链块最近的确认块（离创世区块最近），则从已入链块开始分叉到新确认块，此新不可逆区块（较矮）成为当前节点最高不可逆区块，之前更高的不可逆区块虽然收集到了至少 `n-f` 个签名，但由于离创世区块更远，被认为是分叉区块， 从原废弃的不可逆区块到分叉点所在区块上的交易， 需要重新决定是否要返回 `pending` 队列中。

## 流程图

![Logic](./concurrent-bft/images/cbfg_logic.png)

如图，`CBFT`实施过程大概步骤解释如下：

当某个节点处于一轮出块窗口期时，其可以连续性的出多个块。如图所示，假设窗口期节点连续性的出了区块N和N+1。打包后的区块会被签名，然后广播给其它的共识节点。当共识节点收到新的区块后会进行区块验证及签名验证，如果验证通过，那么就会对区块再次签名，签名后的区块将再次被广播出去。所有的共识节点会连续性的收到区块N，N+1的数据，不需要等待区块N被确认，可以同时对N+1个区块进行共识。当每个共识节点收集齐3f+1个签名后则该区块成功被确认。




